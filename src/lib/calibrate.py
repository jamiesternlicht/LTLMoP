#!/usr/bin/env python
# -*- coding: us-ascii -*-
# generated by wxGlade 0.6.3 on Sat Feb  6 08:25:38 2010

""" =====================================================================================
    calibrate.py - A tool for finding the transformation between map and real coordinates
    =====================================================================================
    
    This script helps you experimentally determine the coordinate transformation
    between points on your region map and points in your localization system.

    The specific points used for calibration are chosen in the Region Editor.

    :Usage: ``calibrate.py [spec_file]``
"""

import wx, sys, os
import fileMethods, regions, project
from numpy import *

# begin wxGlade: extracode
# end wxGlade

class CalibrateFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: CalibrateFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.bitmap_map = wx.StaticBitmap(self, -1, wx.NullBitmap)
        self.label_instructions = wx.StaticText(self, -1, "Welcome to the LTLMoP Calibration Tool")
        self.button_go = wx.Button(self, -1, "Begin")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.onButtonGo, self.button_go)
        # end wxGlade

        if len(sys.argv) < 2:
            print "You must specify a specification file."
            print "Usage: %s [spec_file] [exp_config_name]" % sys.argv[0]
            sys.exit(2)

        # Load configuration files

        self.proj = project.Project()

        if len(sys.argv) == 2:
            self.proj.loadProject(sys.argv[1])
        else:
            self.proj.loadProject(sys.argv[1], exp_cfg_name=sys.argv[2])

        # Initialize the init and pose handlers

        self.proj.lookupHandlers()
        print "Importing handler functions..."
        self.proj.runInitialization(calib=True)
        self.proj.importHandlers(['pose'])

        map_filename = self.proj.getBackgroundImagePath()
        self.setMapImage(map_filename)

        self.Bind(wx.EVT_SIZE, self.onResize, self)

        # Start timer for blinking
        self.circlex = None
        self.circley = None
        self.timer = wx.Timer(self)
        self.timer.Start(500)
        self.Bind(wx.EVT_TIMER, self.drawRobot)

        self.calibrationWizard = self.doCalibration()

    def setStepInfo(self, label, button):
        self.label_instructions.SetLabel(label)
        self.button_go.SetLabel(button)
        self.Layout()
        self.Refresh()

    def doCalibration(self):
        # Load the calibration points from region file
        
        pt_names = []
        file_pts = None
        for [name, index, x, y] in self.proj.rfi.getCalibrationPoints():
            pt_names.append(name + "_P" + str(index))
            new_pt = mat([float(x), float(y)]).T
            if file_pts is None:
                file_pts = new_pt
            else:
                file_pts = hstack([file_pts, new_pt])

        if file_pts is None or file_pts.shape[1] < 2:
            wx.MessageBox("Please choose at least two points in Region Editor for calibration.  Quitting.", "Error", wx.OK)
            sys.exit(0)

        # Get real coordinates for calibration points
        real_pts = None
        for i, point in enumerate(file_pts.T):
            # Show blinking circle on map
            self.circlex = point[0,0]
            self.circley = point[0,1]

            self.setStepInfo('Please place robot at Point %s shown on the map and press [Capture].' % pt_names[i], "Capture")
            yield

            self.circlex = None # Disable blinking circle

            pose = self.proj.pose_handler.getPose()

            new_pt = mat(pose[0:2]).T
            if real_pts is None:
                real_pts = new_pt
            else:
                real_pts = hstack([real_pts, new_pt])

            self.setStepInfo('Read real point %s coordinate of [%f, %f].' % (pt_names[i], pose[0], pose[1]), "Continue")
            yield
        
        # Calculate transformation:
        # TODO: Allow for full affine transforms
        scale = (real_pts[:,0]-real_pts[:,1])/(file_pts[:,0]-file_pts[:,1])
        xscale = scale[0,0]
        yscale = scale[1,0]
        offset = real_pts[:,0]-(diagflat(scale)*file_pts[:,0])
        xoffset = offset[0,0]
        yoffset = offset[1,0]

        self.setStepInfo("Calibration complete. (xReal = %f*xPixel + %f, yReal = %f*yPixel + %f)" % (xscale, xoffset, yscale, yoffset), "Quit")

        # Sends the data back to SpecEditor via STDERR
        print >> sys.stderr, "CALIB:"+"\t".join(map(str,[xscale, xoffset, yscale, yoffset]))
        yield

    def drawRobot(self, event, state=[False]):
        if self.circlex is not None and self.circley is not None:
            memory = wx.MemoryDC()
            newMap = wx.BitmapFromImage(self.scaledMap)
            memory.SelectObject(newMap)

            memory.BeginDrawing()
            if not state[0]:
                memory.DrawCircle(self.circlex*self.mapScale, self.circley*self.mapScale, 15)
                state[0] = True
            else:
                state[0] = False

            memory.EndDrawing()
            memory.SelectObject(wx.NullBitmap)
            self.bitmap_map.SetBitmap(newMap)

    def onResize(self, event=None):
        # Figure out scaling
        maximumWidth = self.bitmap_map.GetSize().x
        maximumHeight = self.bitmap_map.GetSize().y
        windowAspect = 1.0*maximumHeight/maximumWidth

        W = self.originalMap.GetWidth()
        H = self.originalMap.GetHeight()
        imgAspect = 1.0*H/W

        if imgAspect >= windowAspect:
            NewH = maximumHeight
            self.mapScale = 1.0*NewH/H
            NewW = W * self.mapScale
        else:
            NewW = maximumWidth
            self.mapScale = 1.0*NewW/W
            NewH = H * self.mapScale

        self.scaledMap = self.originalMap.Scale(NewW, NewH)

        # Set background
        self.bitmap_map.SetBitmap(wx.BitmapFromImage(self.scaledMap))

        if event is not None:
            event.Skip()

    def setMapImage(self, filename):
        # Load and display the Map
        self.originalMap = wx.Image(filename, wx.BITMAP_TYPE_PNG)
        self.onResize()


    def __set_properties(self):
        # begin wxGlade: CalibrateFrame.__set_properties
        self.SetTitle("Calibration Tool")
        self.SetSize((898, 632))
        self.label_instructions.SetFont(wx.Font(14, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, "Lucida Grande"))
        self.button_go.SetDefault()
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: CalibrateFrame.__do_layout
        sizer_1 = wx.BoxSizer(wx.VERTICAL)
        sizer_2 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_1.Add(self.bitmap_map, 1, wx.EXPAND, 0)
        sizer_1.Add((20, 15), 0, 0, 0)
        sizer_2.Add((15, 20), 0, 0, 0)
        sizer_2.Add(self.label_instructions, 1, 0, 0)
        sizer_2.Add(self.button_go, 0, 0, 0)
        sizer_2.Add((15, 20), 0, 0, 0)
        sizer_1.Add(sizer_2, 0, wx.EXPAND, 0)
        sizer_1.Add((20, 15), 0, 0, 0)
        self.SetSizer(sizer_1)
        self.Layout()
        # end wxGlade

    def onButtonGo(self, event): # wxGlade: CalibrateFrame.<event_handler>
        try:
            self.calibrationWizard.next()
        except StopIteration:
            sys.exit(0)
        event.Skip()

# end of class CalibrateFrame


class CalibrateApp(wx.App):
    def OnInit(self):
        wx.InitAllImageHandlers()
        frame_1 = CalibrateFrame(None, -1, "")
        self.SetTopWindow(frame_1)
        frame_1.Show()
        return 1

# end of class CalibrateApp

if __name__ == "__main__":
    calibrate = CalibrateApp(0)
    calibrate.MainLoop()
